<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DavidChan&#39;s Blog</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2025-09-28T17:17:04.497Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>DavidChan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vibeBot 实战操作指南</title>
    <link href="http://yoursite.com/2025/09/27/vibeBot%20%E5%AE%9E%E6%88%98%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2025/09/27/vibeBot%20%E5%AE%9E%E6%88%98%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</id>
    <published>2025-09-27T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.497Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#1-xiang-mu-gai-lan">1. 项目概览</a></li><li><a href="#2-kuai-su-shang-shou-liu-cheng">2. 快速上手流程</a></li><li><a href="#3-chang-yong-cao-zuo-qing-dan">3. 常用操作清单</a></li><li><a href="#4-ri-zhi-yu-jian-kong-yao-dian">4. 日志与监控要点</a></li><li><a href="#5-mo-xing-qie-huan-yu-context7-zeng-qiang">5. 模型切换与 Context7 增强</a></li><li><a href="#6-faq-yu-pai-zhang">6. FAQ 与排障</a></li><li><a href="#7-zui-jia-shi-jian-yu-an-quan-jian-yi">7. 最佳实践与安全建议</a></li><li><a href="#8-can-kao-zi-liao">8. 参考资料</a></li></ul><!-- tocstop --></div><h1><span id="1-xiang-mu-gai-lan">1. 项目概览</span><a href="#1-xiang-mu-gai-lan" class="header-anchor">#</a></h1><ul><li>vibeBot 是一套“Telegram → Mac CLI → Telegram 回推”的自动化工作流，核心由 <code>bot.py</code>（aiogram 3 Worker）驱动，通过 tmux 与本地模型 CLI 协作，关键步骤整理自 <code>/Users/david/hypha/tools/vibeBot/README.md</code>，亦可配合 <a href="https://github.com/upstash/context7/blob/master/README.md" target="_blank" rel="noopener">Context7 官方说明</a> 获取最新文档上下文。</li><li>项目主目录分为三类：运行脚本 (<code>scripts/*.sh</code>)、模型配置 (<code>scripts/models/*.sh</code>)、运行日志 (<code>logs/&lt;model&gt;/&lt;project&gt;/…</code>)，结合 <code>.env</code> 与 <code>config/projects.json</code> 管理多项目实例。</li><li>定位：提供统一的 master bot 控制入口，同时为每个项目启动独立 worker，满足多模型（Codex/ClaudeCode/Gemini）并行处理需求。</li></ul><h1><span id="2-kuai-su-shang-shou-liu-cheng">2. 快速上手流程</span><a href="#2-kuai-su-shang-shou-liu-cheng" class="header-anchor">#</a></h1><ol><li>准备环境：确保 macOS 具备 Python 3.11+、tmux、Telegram Bot Token。</li><li>初始化配置：<ul><li>复制模板：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/vibeBot</span><br><span class="line">cp .env.example .env</span><br><span class="line">cp config/projects.sample.json config/projects.json</span><br></pre></td></tr></table></figure></li><li>在 <code>.env</code> 中仅填写 master 侧参数：<code>MASTER_BOT_TOKEN</code>、<code>MASTER_WHITELIST</code>、<code>MODEL_DEFAULT</code>、<code>TMUX_SESSION_PREFIX</code> 等。</li><li>在 <code>config/projects.json</code> 为每个项目写入 <code>bot_name</code>、<code>bot_token</code>、<code>project_slug</code>、<code>default_model</code>、<code>workdir</code> 等字段，<code>allowed_chat_id</code> 留空可自动记录首个合法会话。</li></ul></li><li>启动并验证：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./scripts/run_bot.sh --model codex --project mall-backend</span><br><span class="line">tail -f logs/codex/mall-backend/run_bot.log</span><br></pre></td></tr></table></figure><ul><li><code>run_bot.sh</code> 自动创建虚拟环境、安装依赖、启动 tmux session，再调用模型 CLI 与 <code>bot.py</code>。</li><li>如需前台调试，可追加 <code>--foreground</code>；要跳过预先 stop，加 <code>--no-stop</code>。</li></ul></li><li>停止或切换：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./scripts/stop_bot.sh --model codex --project mall-backend</span><br><span class="line">./scripts/run_bot.sh --model claudecode --project mall-backend</span><br></pre></td></tr></table></figure><ul><li><code>stop_bot.sh</code> 会尝试 <code>tmux kill-session</code>、结束 <code>bot.pid</code> 指定进程并清理缓存，确保切换模型时幂等。</li></ul></li></ol><h1><span id="3-chang-yong-cao-zuo-qing-dan">3. 常用操作清单</span><a href="#3-chang-yong-cao-zuo-qing-dan" class="header-anchor">#</a></h1><table><thead><tr><th>场景</th><th>脚本/命令</th><th>说明</th></tr></thead><tbody><tr><td>启动 worker</td><td><code>./scripts/run_bot.sh --model &lt;name&gt; --project &lt;slug&gt;</code></td><td>自动建 venv、导入配置并后台运行，可加 <code>--foreground</code> 调试</td></tr><tr><td>停止 worker</td><td><code>./scripts/stop_bot.sh --model &lt;name&gt; --project &lt;slug&gt;</code></td><td>关闭 tmux session 与 <code>bot.py</code>，删除临时状态</td></tr><tr><td>查看模型日志</td><td><code>tail -f logs/&lt;model&gt;/&lt;project&gt;/model.log</code></td><td>由 tmux pipe-pane 捕获模型 CLI 输出，排查上下文注入是否成功</td></tr><tr><td>查看运行日志</td><td><code>tail -f logs/&lt;model&gt;/&lt;project&gt;/run_bot.log</code></td><td>记录脚本启动流程、<code>.env</code> 解析、依赖安装信息</td></tr><tr><td>当前会话定位</td><td><code>cat logs/&lt;model&gt;/&lt;project&gt;/current_session.txt</code></td><td>存储 JSONL 会话路径，便于追踪同一对话上下文</td></tr><tr><td>Master 控制</td><td><code>/projects</code>、<code>/run &lt;project&gt;</code>、<code>/stop &lt;project&gt;</code></td><td>通过管理员 bot（<code>MASTER_BOT_TOKEN</code>）统一指挥，状态写入 <code>state/state.json</code></td></tr></tbody></table><h1><span id="4-ri-zhi-yu-jian-kong-yao-dian">4. 日志与监控要点</span><a href="#4-ri-zhi-yu-jian-kong-yao-dian" class="header-anchor">#</a></h1><ul><li>目录结构：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">logs&#x2F;</span><br><span class="line">  └─ codex&#x2F;</span><br><span class="line">      └─ mall-backend&#x2F;</span><br><span class="line">           ├─ run_bot.log</span><br><span class="line">           ├─ model.log</span><br><span class="line">           ├─ bot.pid</span><br><span class="line">           └─ current_session.txt</span><br></pre></td></tr></table></figure></li><li>诊断建议：<ul><li><code>run_bot.log</code> 关注虚拟环境创建、依赖安装与 tmux session 名称。</li><li><code>model.log</code> 可校验命令注入与模型输出是否超时。</li><li><code>current_session.txt</code> 指向 JSONL 历史记录，出错时可配合 Context7 调取代码文档，快速定位 prompt。</li></ul></li></ul><h1><span id="5-mo-xing-qie-huan-yu-context7-zeng-qiang">5. 模型切换与 Context7 增强</span><a href="#5-mo-xing-qie-huan-yu-context7-zeng-qiang" class="header-anchor">#</a></h1><ul><li><code>scripts/models/</code> 目录分别维护 <code>codex.sh</code>、<code>claudecode.sh</code>、<code>gemini.sh</code>，公共逻辑在 <code>common.sh</code>，确保互不干扰。</li><li>切换步骤：先执行 <code>stop_bot.sh --model &lt;旧&gt;</code>，再 <code>run_bot.sh --model &lt;新&gt;</code>，<code>ACTIVE_MODEL</code> 会在 <code>/start</code> 回复中提示。</li><li>在 Cursor 等 IDE 中，可直接在 prompt 末尾追加 <code>use context7</code>，即时拉取依赖库或脚本的最新文档示例：<a href="https://github.com/upstash/context7/blob/master/README.md" target="_blank" rel="noopener">官方说明</a>。</li><li>CLI 集成示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx @upstash/context7-mcp@latest --transport stdio</span><br></pre></td></tr></table></figure><ul><li>结合 vibeBot，可在 watcher 阶段读取 Context7 返回的上下文片段，提高多模型协同准确度。</li></ul></li></ul><h1><span id="6-faq-yu-pai-zhang">6. FAQ 与排障</span><a href="#6-faq-yu-pai-zhang" class="header-anchor">#</a></h1><ul><li><strong>为何 <code>.env</code> 只配置 master？</strong> 项目级 Token 放在 <code>config/projects.json</code>，便于按项目授权与版本控制。</li><li><strong><code>allowed_chat_id</code> 为空会怎样？</strong> worker 首次收到合法消息会写入 <code>state/state.json</code>，后续自动鉴权。</li><li><strong>如何定位命令未执行？</strong> 查看 <code>model.log</code> 是否存在 prompt 注入日志，必要时进入 tmux 会话手工输入。</li><li><strong>tmux 会话残留怎么办？</strong> <code>stop_bot.sh</code> 已对 <code>tmux kill-session</code> 和 <code>bot.pid</code> 做了幂等处理，若仍存在需手动 <code>tmux ls</code> 排查，同步清理。</li><li><strong>日志过大</strong>：定期清理 <code>logs/&lt;model&gt;/&lt;project&gt;/</code> 或调整脚本输出阈值；注意不要删除当前会话 JSONL。</li></ul><h1><span id="7-zui-jia-shi-jian-yu-an-quan-jian-yi">7. 最佳实践与安全建议</span><a href="#7-zui-jia-shi-jian-yu-an-quan-jian-yi" class="header-anchor">#</a></h1><ul><li>不要将 <code>.env</code>、<code>config/projects.json</code> 提交版本库；敏感 Token 改用 CI/CD 密钥或 macOS 钥匙串。</li><li>切换模型前务必执行 <code>stop_bot.sh</code>，避免多实例争用 tmux 名称或 JSONL 文件。</li><li>建议将 <code>run_bot.log</code>、<code>model.log</code> 纳入集中日志系统，配合 Context7 检索最新脚本变更。</li><li>定期运行 <code>./scripts/stop_bot.sh --model &lt;name&gt; --project &lt;slug&gt;</code> 做健康检查，确认 <code>bot.pid</code> 已释放。</li></ul><h1><span id="8-can-kao-zi-liao">8. 参考资料</span><a href="#8-can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li><code>/Users/david/hypha/tools/vibeBot/README.md</code></li><li>Context7 MCP 官方文档：<a href="https://github.com/upstash/context7/blob/master/README.md" target="_blank" rel="noopener">https://github.com/upstash/context7/blob/master/README.md</a></li><li>Hexo 写作规范：<a href="https://hexo.io/docs/writing" target="_blank" rel="noopener">https://hexo.io/docs/writing</a></li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Tools" scheme="http://yoursite.com/tags/Tools/"/>
    
    <category term="#AI" scheme="http://yoursite.com/tags/AI/"/>
    
    <category term="#vibe" scheme="http://yoursite.com/tags/vibe/"/>
    
  </entry>
  
  <entry>
    <title>DBA运维指标体系与SRE协作</title>
    <link href="http://yoursite.com/2024/07/12/DB-DBA%E8%BF%90%E7%BB%B4%E6%8C%87%E6%A0%87%E4%BD%93%E7%B3%BB%E4%B8%8ESRE%E5%8D%8F%E4%BD%9C/"/>
    <id>http://yoursite.com/2024/07/12/DB-DBA%E8%BF%90%E7%BB%B4%E6%8C%87%E6%A0%87%E4%BD%93%E7%B3%BB%E4%B8%8ESRE%E5%8D%8F%E4%BD%9C/</id>
    <published>2024-07-12T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.492Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#zhi-biao-ti-xi">指标体系</a></li><li><a href="#xie-zuo-liu-cheng">协作流程</a></li><li><a href="#gong-ju">工具</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>数据库运维需要与 SRE 协同构建指标体系，保障稳定性。本文介绍关键指标、协作流程与工具。</p></blockquote><h1><span id="zhi-biao-ti-xi">指标体系</span><a href="#zhi-biao-ti-xi" class="header-anchor">#</a></h1><ul><li>可用性：故障率、恢复时间（MTTR）；</li><li>性能：QPS/TPS、慢查询、锁等待；</li><li>资源：CPU、IO、Buffer Pool；</li><li>变更：DDL 次数、成功率；</li><li>安全：审计日志、权限变更。</li></ul><h1><span id="xie-zuo-liu-cheng">协作流程</span><a href="#xie-zuo-liu-cheng" class="header-anchor">#</a></h1><ul><li>DBA 提供指标定义，SRE 负责监控平台；</li><li>成立数据库战情室，处理重大事件；</li><li>定期复盘，优化告警；</li><li>建立 Runbook 与自动化脚本。</li></ul><h1><span id="gong-ju">工具</span><a href="#gong-ju" class="header-anchor">#</a></h1><ul><li>Prometheus + Grafana Dashboard；</li><li>慢 SQL 分析（pt-query-digest、AWR）；</li><li>自动化平台（Ansible、DBA 工具）；</li><li>事件管理平台（PagerDuty、Opsgenie）。</li></ul><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>完善的指标体系与 SRE 协作机制可以提升数据库运维效率，降低故障风险。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] Google SRE Book, Monitoring Chapter.</li><li>[2] Percona Monitoring and Management (PMM).</li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>分布式数据库选型与评估框架</title>
    <link href="http://yoursite.com/2024/07/02/DB-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%89%E5%9E%8B%E4%B8%8E%E8%AF%84%E4%BC%B0%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2024/07/02/DB-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%89%E5%9E%8B%E4%B8%8E%E8%AF%84%E4%BC%B0%E6%A1%86%E6%9E%B6/</id>
    <published>2024-07-02T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.493Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#ping-gu-wei-du">评估维度</a></li><li><a href="#ping-gu-liu-cheng">评估流程</a></li><li><a href="#chang-jian-shu-ju-ku">常见数据库</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>分布式数据库种类繁多，选型需要系统化评估。本文提供评估维度、流程与常见数据库对比。</p></blockquote><h1><span id="ping-gu-wei-du">评估维度</span><a href="#ping-gu-wei-du" class="header-anchor">#</a></h1><ul><li>数据模型（关系、NewSQL、NoSQL）；</li><li>一致性、隔离级别；</li><li>可扩展性与延迟；</li><li>成本、生态、社区活跃度；</li><li>运维难度与工具支持。</li></ul><h1><span id="ping-gu-liu-cheng">评估流程</span><a href="#ping-gu-liu-cheng" class="header-anchor">#</a></h1><ol><li>收集业务需求（数据量、交易特征）；</li><li>候选列表调研；</li><li>设计 POC 场景；</li><li>指标采集：延迟、吞吐、故障恢复；</li><li>综合得分与决策；</li><li>评估迁移成本。</li></ol><h1><span id="chang-jian-shu-ju-ku">常见数据库</span><a href="#chang-jian-shu-ju-ku" class="header-anchor">#</a></h1><ul><li>TiDB、CockroachDB（NewSQL）；</li><li>MongoDB、Cassandra（NoSQL）；</li><li>PolarDB、Aurora（云原生）。</li></ul><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>分布式数据库选型需结合业务、技术和成本多维度。通过标准化评估框架，可降低选型风险。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] Gartner Database Magic Quadrant.</li><li>[2] CNCF Landscape 数据库章节.</li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>数据湖与数据仓库融合架构</title>
    <link href="http://yoursite.com/2024/06/22/DB-%E6%95%B0%E6%8D%AE%E6%B9%96%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E8%9E%8D%E5%90%88%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2024/06/22/DB-%E6%95%B0%E6%8D%AE%E6%B9%96%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E8%9E%8D%E5%90%88%E6%9E%B6%E6%9E%84/</id>
    <published>2024-06-22T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.493Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#rong-he-jia-gou">融合架构</a></li><li><a href="#guan-jian-ji-zhu">关键技术</a></li><li><a href="#ying-yong-chang-jing">应用场景</a></li><li><a href="#shi-jian-jian-yi">实践建议</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>数据湖与数据仓库的融合（Lakehouse）成为趋势。本文梳理架构模式、关键技术与企业落地案例。</p></blockquote><h1><span id="rong-he-jia-gou">融合架构</span><a href="#rong-he-jia-gou" class="header-anchor">#</a></h1><ul><li>统一存储（对象存储）+ 统一计算；</li><li>数据湖管理原始数据，数据仓库提供结构化分析；</li><li>元数据管理（Hive Metastore、Glue）；</li><li>表格式：Iceberg、Delta Lake、Hudi。</li></ul><h1><span id="guan-jian-ji-zhu">关键技术</span><a href="#guan-jian-ji-zhu" class="header-anchor">#</a></h1><ul><li>ACID Table Format；</li><li>流批一体处理（Spark、Flink）；</li><li>数据治理：血缘、质量、权限；</li><li>查询引擎：Presto/Trino、Athena。</li></ul><h1><span id="ying-yong-chang-jing">应用场景</span><a href="#ying-yong-chang-jing" class="header-anchor">#</a></h1><ul><li>实时分析与历史分析统一；</li><li>多租户数据平台；</li><li>数据民主化、API 服务化。</li></ul><h1><span id="shi-jian-jian-yi">实践建议</span><a href="#shi-jian-jian-yi" class="header-anchor">#</a></h1><ul><li>选择合适的表格式；</li><li>建立数据目录与治理流程；</li><li>关注成本与性能均衡；</li><li>自动化数据质量检测。</li></ul><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>Lakehouse 架构打通数据湖与仓库的边界。通过标准化表格式、治理模块与统一计算引擎，可以构建灵活的数据平台。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] Databricks Lakehouse Whitepaper.</li><li>[2] Apache Iceberg Project Docs.</li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>数据库容量预测与伸缩策略</title>
    <link href="http://yoursite.com/2024/06/12/DB-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%B9%E9%87%8F%E9%A2%84%E6%B5%8B%E4%B8%8E%E4%BC%B8%E7%BC%A9%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2024/06/12/DB-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%B9%E9%87%8F%E9%A2%84%E6%B5%8B%E4%B8%8E%E4%BC%B8%E7%BC%A9%E7%AD%96%E7%95%A5/</id>
    <published>2024-06-12T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.493Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#shu-ju-shou-ji">数据收集</a></li><li><a href="#yu-ce-mo-xing">预测模型</a></li><li><a href="#shen-suo-ce-lue">伸缩策略</a></li><li><a href="#liu-cheng">流程</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>容量规划与预测是数据库运维的关键。本文分享容量预测模型、监控指标与伸缩策略。</p></blockquote><h1><span id="shu-ju-shou-ji">数据收集</span><a href="#shu-ju-shou-ji" class="header-anchor">#</a></h1><ul><li>历史数据量、增长率；</li><li>TPS、QPS、连接数；</li><li>磁盘使用、IOPS；</li><li>备份与日志空间。</li></ul><h1><span id="yu-ce-mo-xing">预测模型</span><a href="#yu-ce-mo-xing" class="header-anchor">#</a></h1><ul><li>线性回归；</li><li>季节性模型（ARIMA、Prophet）；</li><li>指标阈值报警；</li><li>结合业务计划（促销、活动）。</li></ul><h1><span id="shen-suo-ce-lue">伸缩策略</span><a href="#shen-suo-ce-lue" class="header-anchor">#</a></h1><ul><li>垂直扩容：升级实例规格；</li><li>水平拆分：分库分表、分片；</li><li>读写分离；</li><li>云数据库自动扩缩容。</li></ul><h1><span id="liu-cheng">流程</span><a href="#liu-cheng" class="header-anchor">#</a></h1><ol><li>周期性统计数据；</li><li>预测未来需求；</li><li>评估扩容方案；</li><li>演练缩容与迁移；</li><li>记录决策与结果。</li></ol><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>数据库容量规划需要数据驱动与流程保障。通过准确预测与灵活伸缩，确保性能与成本平衡。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] Google SRE Workbook Capacity Planning.</li><li>[2] AWS Well-Architected Framework.</li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>多活数据库冲突检测与解决</title>
    <link href="http://yoursite.com/2024/06/02/DB-%E5%A4%9A%E6%B4%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%B2%E7%AA%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2024/06/02/DB-%E5%A4%9A%E6%B4%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%B2%E7%AA%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A7%A3%E5%86%B3/</id>
    <published>2024-06-02T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.493Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#chong-tu-lai-yuan">冲突来源</a></li><li><a href="#jian-ce-ji-zhi">检测机制</a></li><li><a href="#jie-jue-ce-lue">解决策略</a></li><li><a href="#shi-jian-an-li">实践案例</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>多活数据库部署提高可用性，但跨节点写入可能产生冲突。本文总结冲突检测机制与解决策略。</p></blockquote><h1><span id="chong-tu-lai-yuan">冲突来源</span><a href="#chong-tu-lai-yuan" class="header-anchor">#</a></h1><ul><li>数据写入同时发生在不同节点；</li><li>时钟不同步；</li><li>业务逻辑缺乏幂等设计。</li></ul><h1><span id="jian-ce-ji-zhi">检测机制</span><a href="#jian-ce-ji-zhi" class="header-anchor">#</a></h1><ul><li>基于版本号/时间戳（Vector Clock、Lamport）；</li><li>业务唯一键；</li><li>事件日志对账；</li><li>应用层冲突队列。</li></ul><h1><span id="jie-jue-ce-lue">解决策略</span><a href="#jie-jue-ce-lue" class="header-anchor">#</a></h1><ul><li>最终写入胜（Last Writer Wins）；</li><li>合并策略（CRDT、基于业务规则）；</li><li>人工审核；</li><li>防止冲突：写路由、租户隔离、同步复制。</li></ul><h1><span id="shi-jian-an-li">实践案例</span><a href="#shi-jian-an-li" class="header-anchor">#</a></h1><ul><li>双活 MySQL 使用 GTID + 判断冲突表；</li><li>Cosmos DB/ DynamoDB CRDT 模型；</li><li>数据对账工具（Debezium 对比）。</li></ul><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>多活冲突不可避免，需要设计检测与解决流程。通过版本控制、幂等和业务规则，可降低冲突影响。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] Google Spanner Whitepaper.</li><li>[2] Azure Cosmos DB Conflict Resolution.</li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>数据加密与脱敏落地实践</title>
    <link href="http://yoursite.com/2024/05/23/DB-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%84%B1%E6%95%8F%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2024/05/23/DB-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%84%B1%E6%95%8F%E8%90%BD%E5%9C%B0%E5%AE%9E%E8%B7%B5/</id>
    <published>2024-05-23T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.493Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#jia-mi-ce-lue">加密策略</a></li><li><a href="#tuo-min-fang-shi">脱敏方式</a></li><li><a href="#shi-jian-jian-yi">实践建议</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>数据安全法规要求对敏感数据进行加密与脱敏。本文介绍数据库层加密、应用层加密和脱敏方案。</p></blockquote><h1><span id="jia-mi-ce-lue">加密策略</span><a href="#jia-mi-ce-lue" class="header-anchor">#</a></h1><ul><li><strong>静态数据加密</strong>：TDE（Transparent Data Encryption）、磁盘加密；</li><li><strong>传输加密</strong>：TLS/SSL；</li><li><strong>应用层加密</strong>：字段级加密、Envelope Encryption；</li><li>密钥管理：KMS、HSM、Vault。</li></ul><h1><span id="tuo-min-fang-shi">脱敏方式</span><a href="#tuo-min-fang-shi" class="header-anchor">#</a></h1><ul><li>静态脱敏：导出数据脱敏；</li><li>动态脱敏：中间件实时脱敏；</li><li>常用算法：掩码、置换、哈希；</li><li>规则管理：按字段类型制定策略。</li></ul><h1><span id="shi-jian-jian-yi">实践建议</span><a href="#shi-jian-jian-yi" class="header-anchor">#</a></h1><ul><li>分类分级，识别敏感字段；</li><li>建立密钥轮换机制；</li><li>记录访问审计日志；</li><li>结合权限、最小授权；</li><li>定期评估合规性（GDPR、等保）。</li></ul><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>数据加密与脱敏需要与业务流程结合。通过完善的策略、工具与审计体系，可满足合规要求并保护数据安全。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] NIST SP 800-111: Storage Encryption Technologies.</li><li>[2] 阿里云/华为云数据库加密实践文档.</li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>云数据库成本优化与资源治理</title>
    <link href="http://yoursite.com/2024/05/13/DB-%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E6%88%90%E6%9C%AC%E4%BC%98%E5%8C%96%E4%B8%8E%E8%B5%84%E6%BA%90%E6%B2%BB%E7%90%86/"/>
    <id>http://yoursite.com/2024/05/13/DB-%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E6%88%90%E6%9C%AC%E4%BC%98%E5%8C%96%E4%B8%8E%E8%B5%84%E6%BA%90%E6%B2%BB%E7%90%86/</id>
    <published>2024-05-13T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.493Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#cheng-ben-fen-xi">成本分析</a></li><li><a href="#you-hua-shou-duan">优化手段</a></li><li><a href="#zhi-li-liu-cheng">治理流程</a></li><li><a href="#gong-ju">工具</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>云数据库按量计费，成本管理是运维重点。本文分享成本优化策略与资源治理实践。</p></blockquote><h1><span id="cheng-ben-fen-xi">成本分析</span><a href="#cheng-ben-fen-xi" class="header-anchor">#</a></h1><ul><li>分类支出：计算、存储、IO、备份；</li><li>利用云厂商账单 API 统计；</li><li>建立成本归属（标签、项目）。</li></ul><h1><span id="you-hua-shou-duan">优化手段</span><a href="#you-hua-shou-duan" class="header-anchor">#</a></h1><ul><li>自动伸缩：根据负载调整实例规格；</li><li>预留实例与 Savings Plan；</li><li>存储分级：热存储、冷备份、归档；</li><li>定期清理无用实例、快照；</li><li>监控空闲连接、未使用数据集。</li></ul><h1><span id="zhi-li-liu-cheng">治理流程</span><a href="#zhi-li-liu-cheng" class="header-anchor">#</a></h1><ul><li>成本预算与报警；</li><li>变更审批纳入成本评估；</li><li>定期审计资源利用率；</li><li>与 FinOps/SRE 协作。</li></ul><h1><span id="gong-ju">工具</span><a href="#gong-ju" class="header-anchor">#</a></h1><ul><li>AWS Cost Explorer、GCP Cost Management；</li><li>第三方 FinOps 平台；</li><li>自建 Dashboard（Grafana + Cost API）。</li></ul><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>云数据库成本优化需要持续监控、自动化治理与跨团队协作。合理配置资源与计费策略，可显著降低运营成本。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] CNCF FinOps Whitepaper.</li><li>[2] AWS Database Cost Optimization Guide.</li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>数据库自动化回滚策略与工具链</title>
    <link href="http://yoursite.com/2024/05/03/DB-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9B%9E%E6%BB%9A%E7%AD%96%E7%95%A5%E4%B8%8E%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
    <id>http://yoursite.com/2024/05/03/DB-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9B%9E%E6%BB%9A%E7%AD%96%E7%95%A5%E4%B8%8E%E5%B7%A5%E5%85%B7%E9%93%BE/</id>
    <published>2024-05-03T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.493Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#hui-gun-ce-lue">回滚策略</a></li><li><a href="#gong-ju-lian">工具链</a></li><li><a href="#liu-cheng">流程</a></li><li><a href="#zui-jia-shi-jian">最佳实践</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>数据库变更失败时需要快速回滚。本文介绍自动化回滚策略、工具与流程。</p></blockquote><h1><span id="hui-gun-ce-lue">回滚策略</span><a href="#hui-gun-ce-lue" class="header-anchor">#</a></h1><ul><li>预生成 Down 脚本；</li><li>快照/备份恢复（逻辑或物理）；</li><li>数据补偿脚本；</li><li>数据对账确认。</li></ul><h1><span id="gong-ju-lian">工具链</span><a href="#gong-ju-lian" class="header-anchor">#</a></h1><ul><li>Flyway/Liquibase Down 脚本；</li><li>MySQL Flashback、Percona Toolkit；</li><li>PostgreSQL Point-in-Time Recovery；</li><li>自动化平台（DBHub、DBmaestro）。</li></ul><h1><span id="liu-cheng">流程</span><a href="#liu-cheng" class="header-anchor">#</a></h1><ol><li>变更前备份或快照；</li><li>变更记录审计；</li><li>故障触发回滚流程；</li><li>执行回滚脚本或恢复；</li><li>验证数据一致性。</li></ol><h1><span id="zui-jia-shi-jian">最佳实践</span><a href="#zui-jia-shi-jian" class="header-anchor">#</a></h1><ul><li>模拟演练，确保回滚脚本可执行；</li><li>变更审批与回滚方案同步审查；</li><li>多环境回滚验证；</li><li>与告警系统集成，快速响应。</li></ul><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>自动化回滚需要完善的工具链与流程。提前规划可在变更失败时迅速恢复。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] Oracle, <em>Database Backup and Recovery User’s Guide</em>.</li><li>[2] Percona Toolkit Documentation.</li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Redis与消息队列联合的缓存一致性设计</title>
    <link href="http://yoursite.com/2024/04/23/DB-Redis%E4%B8%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%81%94%E5%90%88%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2024/04/23/DB-Redis%E4%B8%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%81%94%E5%90%88%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-04-23T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.493Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#mo-shi-yi-cache-aside-yi-bu-tong-zhi">模式一： Cache Aside + 异步通知</a></li><li><a href="#mo-shi-er-shuang-xie-dui-lie">模式二：双写队列</a></li><li><a href="#mo-shi-san-ding-yue-shu-ju-ku-bian-geng">模式三：订阅数据库变更</a></li><li><a href="#ke-kao-xing">可靠性</a></li><li><a href="#jian-kong">监控</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>缓存与数据库之间存在更新延迟。结合消息队列可实现高可靠的缓存一致性。本文总结设计模式与实践。</p></blockquote><h1><span id="mo-shi-yi-cache-aside-yi-bu-tong-zhi">模式一： Cache Aside + 异步通知</span><a href="#mo-shi-yi-cache-aside-yi-bu-tong-zhi" class="header-anchor">#</a></h1><ul><li>更新数据库后发送 MQ 消息；</li><li>消费者刷新或失效缓存；</li><li>支持多实例同步。</li></ul><h1><span id="mo-shi-er-shuang-xie-dui-lie">模式二：双写队列</span><a href="#mo-shi-er-shuang-xie-dui-lie" class="header-anchor">#</a></h1><ul><li>更新请求写入队列；</li><li>消费者串行更新数据库与缓存；</li><li>保证顺序一致。</li></ul><h1><span id="mo-shi-san-ding-yue-shu-ju-ku-bian-geng">模式三：订阅数据库变更</span><a href="#mo-shi-san-ding-yue-shu-ju-ku-bian-geng" class="header-anchor">#</a></h1><ul><li>使用 CDC（Debezium）更新缓存；</li><li>适合多系统共享缓存。</li></ul><h1><span id="ke-kao-xing">可靠性</span><a href="#ke-kao-xing" class="header-anchor">#</a></h1><ul><li>消息幂等处理；</li><li>重试与死信队列；</li><li>缓存失效兜底：短暂回源数据库。</li></ul><h1><span id="jian-kong">监控</span><a href="#jian-kong" class="header-anchor">#</a></h1><ul><li>缓存命中率、刷新失败数；</li><li>MQ 延迟；</li><li>数据一致性对账（采样）；</li><li>告警触发回滚或人工介入。</li></ul><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>利用消息队列辅助缓存更新，可提升一致性与扩展性。关键在于幂等、监控与故障处理设计。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] Alibaba 中台缓存一致性实践.</li><li>[2] Redis Labs Cache Patterns.</li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Debezium CDC与实时数仓同步方案</title>
    <link href="http://yoursite.com/2024/04/13/DB-Debezium-CDC%E5%AE%9E%E6%97%B6%E6%95%B0%E4%BB%93%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2024/04/13/DB-Debezium-CDC%E5%AE%9E%E6%97%B6%E6%95%B0%E4%BB%93%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/</id>
    <published>2024-04-13T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.492Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#jia-gou">架构</a></li><li><a href="#pei-zhi-yao-dian">配置要点</a></li><li><a href="#shi-jian-ce-lue">实践策略</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>Debezium 基于 CDC 捕获数据库变更，是建设实时数仓的关键组件。本文介绍架构、配置与下游同步策略。</p></blockquote><h1><span id="jia-gou">架构</span><a href="#jia-gou" class="header-anchor">#</a></h1><ul><li>Connector 捕获 MySQL/PostgreSQL/Oracle 变更；</li><li>Kafka Connect 传输至 Kafka；</li><li>下游 Sink（Flink、Kafka Streams、Spark）处理；</li><li>Schema Registry 管理模式。</li></ul><h1><span id="pei-zhi-yao-dian">配置要点</span><a href="#pei-zhi-yao-dian" class="header-anchor">#</a></h1><ul><li>MySQL binlog：<code>log_bin</code>, <code>binlog_format=ROW</code>；</li><li>Debezium MySQL Connector 配置 <code>database.include.list</code>, <code>table.include.list</code>；</li><li>事务一致性：<code>snapshot.mode=schema_only</code> 或 <code>initial</code>；</li><li>下游 Sink upsert 写入数据仓库（Snowflake、ClickHouse）。</li></ul><h1><span id="shi-jian-ce-lue">实践策略</span><a href="#shi-jian-ce-lue" class="header-anchor">#</a></h1><ul><li>数据脱敏，避免敏感字段外泄；</li><li>Schema 变更处理（<code>before</code>/<code>after</code>）；</li><li>多表 Join 在下游处理；</li><li>监控延迟 <code>source.lag.milli</code>; </li><li>故障恢复：重置 offset 或使用快照。</li></ul><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>Debezium + Kafka 建立高可靠的实时数据链路。通过精细配置与监控，可实现近实时的数仓同步。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] Debezium Documentation. <a href="https://debezium.io/documentation" target="_blank" rel="noopener">https://debezium.io/documentation</a></li><li>[2] Confluent Platform CDC 参考架构.</li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>数据库模式版本管理与迁移</title>
    <link href="http://yoursite.com/2024/04/03/DB-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%BC%8F%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E4%B8%8E%E8%BF%81%E7%A7%BB/"/>
    <id>http://yoursite.com/2024/04/03/DB-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%BC%8F%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E4%B8%8E%E8%BF%81%E7%A7%BB/</id>
    <published>2024-04-03T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.493Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#ban-ben-guan-li-yuan-ze">版本管理原则</a></li><li><a href="#gong-ju-lian">工具链</a></li><li><a href="#qian-yi-liu-cheng">迁移流程</a></li><li><a href="#zui-jia-shi-jian">最佳实践</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>数据库模式（Schema）演进频繁，缺乏版本管理易导致线上冲突。本文总结迁移策略、工具链与回滚机制。</p></blockquote><h1><span id="ban-ben-guan-li-yuan-ze">版本管理原则</span><a href="#ban-ben-guan-li-yuan-ze" class="header-anchor">#</a></h1><ul><li>DDL 与应用版本同步；</li><li>向后兼容优先，避免破坏性变更；</li><li>使用迁移脚本记录版本；</li><li>审核流程与自动化检测。</li></ul><h1><span id="gong-ju-lian">工具链</span><a href="#gong-ju-lian" class="header-anchor">#</a></h1><ul><li>Flyway、Liquibase、Alembic；</li><li>GitOps 管理 SQL；</li><li>在 CI 中执行迁移测试；</li><li>多环境自动同步。</li></ul><h1><span id="qian-yi-liu-cheng">迁移流程</span><a href="#qian-yi-liu-cheng" class="header-anchor">#</a></h1><ol><li>编写迁移脚本（Up/Down）；</li><li>在测试环境执行并验证；</li><li>生产环境灰度执行；</li><li>监控指标与日志；</li><li>如需回滚执行 Down 脚本或准备回滚脚本。</li></ol><h1><span id="zui-jia-shi-jian">最佳实践</span><a href="#zui-jia-shi-jian" class="header-anchor">#</a></h1><ul><li>对大表采用 Online DDL（Gh-ost、pt-online-schema-change）；</li><li>DDL 与代码解耦，先发布兼容版本；</li><li>使用 Feature Flag 控制新列；</li><li>记录 Schema 版本表 <code>schema_version</code>。</li></ul><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>系统化的模式版本管理可降低数据库变更风险。通过工具链、自动化与回滚策略，保证迁移安全可控。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] Flyway Documentation. <a href="https://documentation.red-gate.com/fd" target="_blank" rel="noopener">https://documentation.red-gate.com/fd</a></li><li>[2] GitHub gh-ost 项目.</li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>TiDB HTAP架构与应用场景分析</title>
    <link href="http://yoursite.com/2024/03/24/DB-TiDB-HTAP%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2024/03/24/DB-TiDB-HTAP%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/</id>
    <published>2024-03-24T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.493Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#jia-gou">架构</a></li><li><a href="#htap-te-xing">HTAP 特性</a></li><li><a href="#ying-yong-chang-jing">应用场景</a></li><li><a href="#diao-you-jian-yi">调优建议</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>TiDB 通过 TiKV + TiFlash 实现 HTAP（Hybrid Transactional and Analytical Processing）。本文介绍架构、查询加速与适用场景。</p></blockquote><h1><span id="jia-gou">架构</span><a href="#jia-gou" class="header-anchor">#</a></h1><ul><li>TiDB Server：SQL 层；</li><li>TiKV：行存储（事务）；</li><li>TiFlash：列存储（分析）；</li><li>PD：集群调度、元数据；</li><li>Raft 复制保证一致性。</li></ul><h1><span id="htap-te-xing">HTAP 特性</span><a href="#htap-te-xing" class="header-anchor">#</a></h1><ul><li>行列双写：写入 TiKV 同步到 TiFlash；</li><li>MPP 引擎：TiFlash 负责分析查询；</li><li>智能优化器根据代价选择执行计划；</li><li>ACID + 实时分析兼顾。</li></ul><h1><span id="ying-yong-chang-jing">应用场景</span><a href="#ying-yong-chang-jing" class="header-anchor">#</a></h1><ul><li>需要实时分析的在线业务（实时报表）；</li><li>替代传统 OLTP+OLAP 分库方案；</li><li>中等规模分析（TB 级）；</li><li>需要弹性扩展。</li></ul><h1><span id="diao-you-jian-yi">调优建议</span><a href="#diao-you-jian-yi" class="header-anchor">#</a></h1><ul><li>合理设置副本数 <code>pd-ctl config set replication</code>；</li><li>对热点数据使用分区表；</li><li>监控 TiFlash 同步延迟；</li><li>结合资源隔离（资源组）提高公平性。</li></ul><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>TiDB 的 HTAP 架构适合实时分析与事务融合的场景。通过 TiFlash、MPP 与资源治理，可实现灵活的混合负载处理。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] PingCAP Docs: TiDB HTAP. <a href="https://docs.pingcap.com/tidb/stable/tidb-overview" target="_blank" rel="noopener">https://docs.pingcap.com/tidb/stable/tidb-overview</a></li><li>[2] TiDB Whitepaper.</li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch查询性能剖析与调优</title>
    <link href="http://yoursite.com/2024/03/14/DB-Elasticsearch%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98/"/>
    <id>http://yoursite.com/2024/03/14/DB-Elasticsearch%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98/</id>
    <published>2024-03-14T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.492Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#xing-neng-zhen-duan">性能诊断</a></li><li><a href="#diao-you-shou-duan">调优手段</a></li><li><a href="#zi-yuan-pei-zhi">资源配置</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>Elasticsearch 查询性能受索引设计、查询 DSL、资源配置影响。本文总结瓶颈分析方法与调优策略。</p></blockquote><h1><span id="xing-neng-zhen-duan">性能诊断</span><a href="#xing-neng-zhen-duan" class="header-anchor">#</a></h1><ul><li>使用 <code>_profile</code> API 分析查询耗时；</li><li>查看 Hot Threads、Task API；</li><li>监控 <code>search.query_time_in_millis</code>；</li><li>Kibana Stack Monitoring 观察节点性能。</li></ul><h1><span id="diao-you-shou-duan">调优手段</span><a href="#diao-you-shou-duan" class="header-anchor">#</a></h1><ul><li>合理 mapping：字段类型、<code>keyword</code> vs <code>text</code>；</li><li>Filter + Query：使用 <code>bool</code>，过滤条件放在 filter；</li><li>使用 <code>doc_values</code> 支持排序聚合；</li><li>控制分页：<code>search_after</code>、<code>scroll</code>；</li><li>缓存：<code>query_cache</code>, <code>request_cache</code>；</li><li>水平扩展：增加分片、副本。</li></ul><h1><span id="zi-yuan-pei-zhi">资源配置</span><a href="#zi-yuan-pei-zhi" class="header-anchor">#</a></h1><ul><li>JVM Heap 约占物理内存 50%，最大 32GB；</li><li>尽量使用 SSD；</li><li>控制 Shard 大小 20GB~50GB；</li><li>禁止长 GC，使用 G1 GC。</li></ul><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>通过查询分析、mapping 调整和资源优化，Elasticsearch 能保持稳定的查询性能。持续监控与压测是关键。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] Elastic Docs: Tune for Search Speed. <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/tune-for-search-speed.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/tune-for-search-speed.html</a></li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch索引生命周期管理与ILM策略</title>
    <link href="http://yoursite.com/2024/03/04/DB-Elasticsearch%E7%B4%A2%E5%BC%95%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86ILM%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2024/03/04/DB-Elasticsearch%E7%B4%A2%E5%BC%95%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86ILM%E7%AD%96%E7%95%A5/</id>
    <published>2024-03-04T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.492Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#ilm-jie-duan">ILM 阶段</a></li><li><a href="#pei-zhi-shi-li">配置示例</a></li><li><a href="#shi-jian-yao-dian">实践要点</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>Elasticsearch Index Lifecycle Management (ILM) 支持索引的热、温、冷、删除多阶段管控。本文介绍 ILM 策略配置、资源优化与实战经验。</p></blockquote><h1><span id="ilm-jie-duan">ILM 阶段</span><a href="#ilm-jie-duan" class="header-anchor">#</a></h1><ul><li>Hot：写入活跃数据；</li><li>Warm：降低副本数、转移至冷存储；</li><li>Cold：只读，可能冻结；</li><li>Delete：删除或快照后删除。</li></ul><h1><span id="pei-zhi-shi-li">配置示例</span><a href="#pei-zhi-shi-li" class="header-anchor">#</a></h1><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"policy"</span>: &#123;</span><br><span class="line">    <span class="attr">"phases"</span>: &#123;</span><br><span class="line">      <span class="attr">"hot"</span>: &#123;</span><br><span class="line">        <span class="attr">"actions"</span>: &#123;</span><br><span class="line">          <span class="attr">"rollover"</span>: &#123; <span class="attr">"max_size"</span>: <span class="string">"50gb"</span>, <span class="attr">"max_age"</span>: <span class="string">"7d"</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"warm"</span>: &#123;</span><br><span class="line">        <span class="attr">"min_age"</span>: <span class="string">"7d"</span>,</span><br><span class="line">        <span class="attr">"actions"</span>: &#123;</span><br><span class="line">          <span class="attr">"shrink"</span>: &#123; <span class="attr">"number_of_shards"</span>: <span class="number">1</span> &#125;,</span><br><span class="line">          <span class="attr">"forcemerge"</span>: &#123; <span class="attr">"max_num_segments"</span>: <span class="number">1</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"delete"</span>: &#123;</span><br><span class="line">        <span class="attr">"min_age"</span>: <span class="string">"30d"</span>,</span><br><span class="line">        <span class="attr">"actions"</span>: &#123; <span class="attr">"delete"</span>: &#123;&#125; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="shi-jian-yao-dian">实践要点</span><a href="#shi-jian-yao-dian" class="header-anchor">#</a></h1><ul><li>结合 Rollover 索引模式 <code>logs-%{+yyyy.MM.dd}</code>；</li><li>使用 <code>Index Templates</code> 自动应用策略；</li><li>监控热节点 CPU、磁盘；</li><li>对日志场景结合 Elasticsearch Snapshot 保存历史。</li></ul><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>ILM 是 Elasticsearch 数据生命周期管理的关键工具。通过分阶段策略与监控，可降低成本并保持查询性能。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] Elastic Docs: Index Lifecycle Management. <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index-lifecycle-management.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/index-lifecycle-management.html</a></li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Redis Stream事件驱动架构设计</title>
    <link href="http://yoursite.com/2024/02/23/DB-Redis-Stream%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2024/02/23/DB-Redis-Stream%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-02-23T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.493Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#shu-ju-jie-gou">数据结构</a></li><li><a href="#jia-gou-shi-yi">架构示意</a></li><li><a href="#ke-kao-xing-ce-lue">可靠性策略</a></li><li><a href="#ying-yong-chang-jing">应用场景</a></li><li><a href="#zui-jia-shi-jian">最佳实践</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>Redis Stream 提供持久化的消息流，适合构建轻量事件驱动架构。本文总结 Stream 的数据结构、消费组、可靠性保障与实践案例。</p></blockquote><h1><span id="shu-ju-jie-gou">数据结构</span><a href="#shu-ju-jie-gou" class="header-anchor">#</a></h1><ul><li>XADD 添加消息，带自动时间戳；</li><li>XREAD/XREADGROUP 读取消息；</li><li>消费组（Consumer Group）支持水平扩展；</li><li>Pending Entries List (PEL) 记录未确认消息。</li></ul><h1><span id="jia-gou-shi-yi">架构示意</span><a href="#jia-gou-shi-yi" class="header-anchor">#</a></h1><pre class="mermaid">graph LR  Producer --> Stream[XADD]  Stream -->|Group| Consumer1  Stream -->|Group| Consumer2  Consumer1 --> ACK  Consumer2 --> ACK</pre><h1><span id="ke-kao-xing-ce-lue">可靠性策略</span><a href="#ke-kao-xing-ce-lue" class="header-anchor">#</a></h1><ul><li>使用 PEL 确保消息不丢；</li><li>定期执行 <code>XPENDING</code>、<code>XCLAIM</code> 重新分配；</li><li>设置 <code>MAXLEN</code> 控制队列长度；</li><li>配合 RDB/AOF 保证持久化。</li></ul><h1><span id="ying-yong-chang-jing">应用场景</span><a href="#ying-yong-chang-jing" class="header-anchor">#</a></h1><ul><li>轻量任务队列、实时指标；</li><li>与 Spring Data Redis、Spring Cloud Stream 集成；</li><li>缓存更新广播、日志聚合。</li></ul><h1><span id="zui-jia-shi-jian">最佳实践</span><a href="#zui-jia-shi-jian" class="header-anchor">#</a></h1><ul><li>消费者批量确认提高吞吐；</li><li>使用 <code>AUTOCLAIM</code> Redis 6.2+ 自动重分配消息；</li><li>监控 <code>XINFO STREAM</code>、<code>XINFO GROUPS</code>；</li><li>定期清理过期数据。</li></ul><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>Redis Stream 结合消费组提供可靠的事件流能力。通过 PEL 管理与定期监控，可满足事件驱动微服务需求。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] Redis Streams Introduction. <a href="https://redis.io/docs/data-types/streams/" target="_blank" rel="noopener">https://redis.io/docs/data-types/streams/</a></li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化策略RDB与AOF取舍</title>
    <link href="http://yoursite.com/2024/02/13/DB-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5RDB%E4%B8%8EAOF%E5%8F%96%E8%88%8D/"/>
    <id>http://yoursite.com/2024/02/13/DB-Redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5RDB%E4%B8%8EAOF%E5%8F%96%E8%88%8D/</id>
    <published>2024-02-13T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.493Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#rdb-kuai-zhao">RDB 快照</a></li><li><a href="#aof-ri-zhi">AOF 日志</a></li><li><a href="#zu-he-ce-lue">组合策略</a></li><li><a href="#yun-wei-yao-dian">运维要点</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>Redis 提供 RDB 与 AOF 两种持久化机制。本文比较两者优缺点，并给出组合使用的实践建议。</p></blockquote><h1><span id="rdb-kuai-zhao">RDB 快照</span><a href="#rdb-kuai-zhao" class="header-anchor">#</a></h1><ul><li>周期性保存内存快照至磁盘；</li><li>配置 <code>save 900 1</code> 等规则；</li><li>体积小，重启快；</li><li>断电可能丢失最后一次快照后的数据。</li></ul><h1><span id="aof-ri-zhi">AOF 日志</span><a href="#aof-ri-zhi" class="header-anchor">#</a></h1><ul><li>记录每个写命令，支持 <code>appendfsync</code> 同步策略；</li><li>可重写（Rewrite）压缩文件；</li><li>数据更安全，体积较大；</li><li><code>appendfsync always</code> 影响性能。</li></ul><h1><span id="zu-he-ce-lue">组合策略</span><a href="#zu-he-ce-lue" class="header-anchor">#</a></h1><ul><li>同时启用 RDB+AOF：启动时优先载入 AOF；</li><li>设置 <code>appendfsync everysec</code>、<code>no-appendfsync-on-rewrite yes</code>；</li><li>定期监控 AOF 重写；</li><li>对内存敏感场景使用 RDB+增量备份。</li></ul><h1><span id="yun-wei-yao-dian">运维要点</span><a href="#yun-wei-yao-dian" class="header-anchor">#</a></h1><ul><li>确保磁盘 IO 足够；</li><li>配置 <code>dir</code> 指向高可靠存储；</li><li>监控 <code>aof_current_size</code>, <code>rdb_changes_since_last_save</code>；</li><li>灾备：定时复制持久化文件至外部存储。</li></ul><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>RDB 快照和 AOF 日志各有优势，结合使用可平衡性能与数据安全。合理配置同步策略与监控是关键。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] Redis Persistence Documentation. <a href="https://redis.io/docs/interact/programmability/persistence/" target="_blank" rel="noopener">https://redis.io/docs/interact/programmability/persistence/</a></li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster容量规划与故障恢复</title>
    <link href="http://yoursite.com/2024/02/03/DB-Redis-Cluster%E5%AE%B9%E9%87%8F%E8%A7%84%E5%88%92%E4%B8%8E%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D/"/>
    <id>http://yoursite.com/2024/02/03/DB-Redis-Cluster%E5%AE%B9%E9%87%8F%E8%A7%84%E5%88%92%E4%B8%8E%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D/</id>
    <published>2024-02-03T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.493Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#rong-liang-gui-hua">容量规划</a></li><li><a href="#gu-zhang-hui-fu">故障恢复</a></li><li><a href="#jian-kong-zhi-biao">监控指标</a></li><li><a href="#yun-wei-jian-yi">运维建议</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>Redis Cluster 通过分片实现扩展。容量规划与故障恢复直接影响高可用。本文总结节点规划、故障处理与监控体系。</p></blockquote><h1><span id="rong-liang-gui-hua">容量规划</span><a href="#rong-liang-gui-hua" class="header-anchor">#</a></h1><ul><li>计算数据量：键数×平均值大小 + Overhead；</li><li>预留副本与冗余，推荐 3 主 3 从；</li><li>Slot 分布均衡，避免热点；</li><li>使用 Cluster Manager 或 <code>redis-cli --cluster create</code>。</li></ul><h1><span id="gu-zhang-hui-fu">故障恢复</span><a href="#gu-zhang-hui-fu" class="header-anchor">#</a></h1><ul><li>主节点故障：从节点自动提升；</li><li>网络分区：大多数党保持可用；</li><li>手动故障转移：<code>redis-cli -c cluster failover</code>；</li><li>注意复制延迟与 <code>min-replicas-to-write</code>。</li></ul><h1><span id="jian-kong-zhi-biao">监控指标</span><a href="#jian-kong-zhi-biao" class="header-anchor">#</a></h1><ul><li><code>cluster info</code>：<code>cluster_state</code>, <code>slots_assigned</code>；</li><li>延迟：<code>latency latest</code>；</li><li>Redis Exporter 指标：内存、命中率、复制偏移；</li><li>Sentinel 或自研监控故障。</li></ul><h1><span id="yun-wei-jian-yi">运维建议</span><a href="#yun-wei-jian-yi" class="header-anchor">#</a></h1><ul><li>定期检查 slot 分布，执行 <code>redis-cli --cluster rebalance</code>；</li><li>控制命令超时时间，防止长任务阻塞；</li><li>使用 RDB/AOF 做备份；</li><li>对大键、热键进行治理。</li></ul><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>Redis Cluster 需要精细的容量规划与故障演练。通过合理的节点配置、监控与备份策略，可保证高可用与性能。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] Redis Cluster Specification. <a href="https://redis.io/docs/interact/cluster-tutorial/" target="_blank" rel="noopener">https://redis.io/docs/interact/cluster-tutorial/</a></li><li>[2] Redis Operability Guide.</li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB多文档事务性能调优</title>
    <link href="http://yoursite.com/2024/01/24/DB-MongoDB%E5%A4%9A%E6%96%87%E6%A1%A3%E4%BA%8B%E5%8A%A1%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>http://yoursite.com/2024/01/24/DB-MongoDB%E5%A4%9A%E6%96%87%E6%A1%A3%E4%BA%8B%E5%8A%A1%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</id>
    <published>2024-01-24T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.493Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#shi-wu-mo-xing">事务模型</a></li><li><a href="#xing-neng-zhi-biao">性能指标</a></li><li><a href="#diao-you-ce-lue">调优策略</a></li><li><a href="#gu-zhang-chu-li">故障处理</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>MongoDB 4.0+ 支持多文档事务，但使用不当会影响性能。本文总结事务模型、性能指标与调优建议。</p></blockquote><h1><span id="shi-wu-mo-xing">事务模型</span><a href="#shi-wu-mo-xing" class="header-anchor">#</a></h1><ul><li>基于 WiredTiger 的 MVCC；</li><li>支持 Replica Set（4.0）与 Sharded Cluster（4.2）；</li><li><code>session.startTransaction()</code> -&gt; <code>commitTransaction()</code>；</li><li>操作数量与执行时间有限制。</li></ul><h1><span id="xing-neng-zhi-biao">性能指标</span><a href="#xing-neng-zhi-biao" class="header-anchor">#</a></h1><ul><li><code>transactionLifetimeLimitSeconds</code> 默认 60s；</li><li>监控 <code>db.serverStatus().transactions</code>；</li><li><code>Current Operations</code> 查看事务锁等待；</li><li><code>metrics.transactions</code> 指标。</li></ul><h1><span id="diao-you-ce-lue">调优策略</span><a href="#diao-you-ce-lue" class="header-anchor">#</a></h1><ul><li>控制事务粒度，减少操作数量；</li><li>避免跨分片事务，优先单分片；</li><li>设置合理的 <code>writeConcern</code> 与 <code>readPreference</code>；</li><li>使用偏好逻辑在应用层避免长事务；</li><li>对热点集合建立合适索引。</li></ul><h1><span id="gu-zhang-chu-li">故障处理</span><a href="#gu-zhang-chu-li" class="header-anchor">#</a></h1><ul><li>事务冲突触发重试：捕获 <code>TransientTransactionError</code>；</li><li>网络中断使用 <code>commitWithRetry</code> 模式；</li><li>结合幂等逻辑确保重试安全。</li></ul><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>MongoDB 事务适合小范围、一致性需求强的场景。控制事务大小与运行时间，并结合监控与重试逻辑，可以平衡一致性与性能。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] MongoDB Transactions Guide. <a href="https://www.mongodb.com/docs/manual/core/transactions/" target="_blank" rel="noopener">https://www.mongodb.com/docs/manual/core/transactions/</a></li><li>[2] MongoDB Best Practices: Transactions.</li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB分片架构与路由优化实践</title>
    <link href="http://yoursite.com/2024/01/14/DB-MongoDB%E5%88%86%E7%89%87%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%B7%AF%E7%94%B1%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2024/01/14/DB-MongoDB%E5%88%86%E7%89%87%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%B7%AF%E7%94%B1%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/</id>
    <published>2024-01-14T16:00:00.000Z</published>
    <updated>2025-09-28T17:17:04.493Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="ben-wen-mu-lu">本文目录</span><a href="#ben-wen-mu-lu" class="header-anchor">#</a></h3><div class="toc"><!-- toc --><ul><li><a href="#yin-yan">引言</a></li><li><a href="#fen-pian-jia-gou">分片架构</a></li><li><a href="#fen-pian-jian-xuan-ze">分片键选择</a></li><li><a href="#lu-you-you-hua">路由优化</a></li><li><a href="#shi-zhan-jian-yi">实战建议</a></li><li><a href="#zong-jie">总结</a></li><li><a href="#can-kao-zi-liao">参考资料</a></li></ul><!-- tocstop --></div><h1><span id="yin-yan">引言</span><a href="#yin-yan" class="header-anchor">#</a></h1><blockquote><p>MongoDB 分片（Sharding）支持水平扩展，但需要精心设计分片键与路由策略。本文总结分片架构、负载均衡与优化实践。</p></blockquote><h1><span id="fen-pian-jia-gou">分片架构</span><a href="#fen-pian-jia-gou" class="header-anchor">#</a></h1><ul><li>Shard：数据存储节点，可为副本集；</li><li>Config Server：存储元数据；</li><li>Mongos：路由进程；</li><li>Chunk：数据分片单位。</li></ul><h1><span id="fen-pian-jian-xuan-ze">分片键选择</span><a href="#fen-pian-jian-xuan-ze" class="header-anchor">#</a></h1><ul><li>均匀分布，避免热点；</li><li>支持范围查询或哈希分片；</li><li>采用复合键结合业务维度；</li><li>分片键不可修改。</li></ul><h1><span id="lu-you-you-hua">路由优化</span><a href="#lu-you-you-hua" class="header-anchor">#</a></h1><ul><li>使用 <code>hashed</code> 分片键避免热点；</li><li>Chunk 迁移：<code>balancer</code> 自动均衡，必要时手动；</li><li>Query 需包含分片键，避免广播；</li><li>监控 <code>chunks</code> 分布、<code>balancer</code> 状态。</li></ul><h1><span id="shi-zhan-jian-yi">实战建议</span><a href="#shi-zhan-jian-yi" class="header-anchor">#</a></h1><ul><li>分析 <code>mongostat</code>, <code>serverStatus</code>，关注 <code>opcounters</code>；</li><li>对热点写入使用预分配 Chunk；</li><li>使用 Tag-aware Sharding 结合地域；</li><li>对大集群启用分片侦测与自动缩容策略。</li></ul><h1><span id="zong-jie">总结</span><a href="#zong-jie" class="header-anchor">#</a></h1><p>合理的分片键与路由策略是 MongoDB 分片性能的关键。通过监控与 Chunk 管理可确保数据均衡与高可用。</p><h1><span id="can-kao-zi-liao">参考资料</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h1><ul><li>[1] MongoDB Manual: Sharding Introduction. <a href="https://www.mongodb.com/docs/manual/sharding/" target="_blank" rel="noopener">https://www.mongodb.com/docs/manual/sharding/</a></li><li>[2] MongoDB Production Notes.</li></ul><hr><p>本作品系原创，采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.≠0/deed.zh" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，转载请注明出处。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"enable":true,"owner":"imchenway","repo":"imchenway.github.io","admin":"imchenway","clientID":"7026ab2c4cdadba4d342","clientSecret":"8e00dadc2db335285be4c861e53ee1bf9f8cc713","distractionFreeMode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;ben-wen-mu-lu&quot;&gt;本文目录&lt;/span&gt;&lt;a href=&quot;#ben-wen-mu-lu&quot; class=&quot;header-anchor&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="#Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
</feed>
